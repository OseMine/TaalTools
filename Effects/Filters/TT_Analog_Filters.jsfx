desc: TaalTools Analog Filters
version: 2.9
author: TaalTools
changelog: + Fixed issues with filter types not producing output
          + Improved filter coefficient calculations
          + Added proper stereo processing
          + Enhanced filter resonance behavior
          + Optimized filter type switching

slider1:0<0,1,1{Stereo,Mono}>Processing
slider2:0<0,7,1{Prophet-5 Rev3,Oberheim OB-X,Oberheim SEM,Korg MS-20,Moog,Moog 4-Pole,Apple 12-Pole,Apple 2-Pole}>Filter Type
slider3:0<0,2,1{LP,HP,BP}>Filter Mode
slider4:1000<20,20000>Frequency (Hz)  
slider5:0<0,0.85,0.001>Resonance
slider6:0<0,100,0.05>Drive (%)
slider7:0<-24,24,0.1>Output (dB) 
slider8:0<0,1,1{On,Off}>Limiter
slider9:0<0,1,1{Off,On}>Oversample (x2)

// Add ReaRack2 MIDI CC modulation sliders
slider10:0<0,1,1{Cutoff level,Resonance}>Modulation Target
slider11:0<0,64,1{Off,0 Bank Sel M,1 Mod Wheel M,2 Breath M,3,4 Foot P M,5 Porta M,6 Data Entry M,7 Vol M,8 Balance M,9,10 Pan M,11 Expression M,12 Ctrl 1 M,13 Ctrl 2 M,14,15,16 GP Slider 1,17 GP Slider 2,18 GP Slider 3,19 GP Slider 4,20,21,22,23,24,25,26,27,28,29,30,31,64 Hold P sw,65 Porta sw,66 Sustenuto sw,67 Soft P sw,68 Legato P sw,69 Hold 2 P sw,70 S.Variation,71 S.Timbre,72 S.Release,73 S.Attack,74 S.Brightness,75 S.Ctrl 6,76 S.Ctrl 7,77 S.Ctrl 8,78 S.Ctrl 9,79 S.Ctrl 10,80 GP B.1 sw,81 GP B.2 sw,82 GP B.3 sw,83 GP B.4 sw,84,85,86,87,88,89,90,91 Effects Lv,92 Trem Lv,93 Chorus Lv,94 Celeste Lv,95 Phaser Lv}>CC Input
slider12:1<0,1,0.001>Modulation Range

@init
ext_tail_size = -1;
cDenorm = 10^-30;
mv = 2^(-0.2/6);
drive = 1;
drvc = 1.2;

// FIR restoration
c1 = 1;
c2 = -0.75;
c3 = 0.17;
fgain = 5;

// Filter states
y1 = y2 = y3 = y4 = 0;
oldx = oldy1 = oldy2 = oldy3 = 0;

// Add ReaRack2 MIDI CC variables
fxn = 300;
ccIn1msb = -1;
ccIn2msb = -1;
ccIn1lsb = ccIn1msb+32;
ccIn2lsb = ccIn2msb+32;
modlevel = 1;

// Add new Moog 4-Pole states
moog4p_y1l = moog4p_y2l = moog4p_y3l = moog4p_y4l = 0;
moog4p_oldxl = moog4p_oldy1l = moog4p_oldy2l = moog4p_oldy3l = 0;
moog4p_y1r = moog4p_y2r = moog4p_y3r = moog4p_y4r = 0;
moog4p_oldxr = moog4p_oldy1r = moog4p_oldy2r = moog4p_oldy3r = 0;

// Add Apple filter state variables
apple_y1l = apple_y2l = apple_y3l = apple_y4l = 0;
apple_mem_l11 = apple_mem_l12 = apple_mem_l13 = apple_mem_l14 = 0;
apple_y1r = apple_y2r = apple_y3r = apple_y4r = 0; 
apple_mem_r11 = apple_mem_r12 = apple_mem_r13 = apple_mem_r14 = 0;

// Add Apple 2-Pole states
apple2p_x1l = apple2p_x2l = apple2p_y1l = apple2p_y2l = 0;
apple2p_x1r = apple2p_x2r = apple2p_y1r = apple2p_y2r = 0;

@slider
mono = slider1;
filtertype = slider2;
filtermode = slider3;
freq = slider4;
res = slider5;
drive = 1 + slider6/100;
outgain = 10^(slider7/20);
limiter = slider8;
oversample = slider9;

// Add ReaRack2 MIDI CC processing
smodp = slider10;
sccIn = slider11;
mrange = slider12;

// Update CC inputs based on modulation target
smodp == 0 ? (
  ccIn1msb = sccIn <= 32 ? sccIn-1:sccIn+31;
  ccIn1lsb = ccIn1msb+32;
  cutrange = mrange;
) : (
  ccIn2msb = sccIn <= 32 ? sccIn-1:sccIn+31;
  ccIn2lsb = ccIn2msb+32;
  resrange = mrange;
);

@block
// Add ReaRack2 MIDI message processing
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & $xF0;
  channel = msg1 & $x0F;
   
  status == $xB0 ? (
    msg2 == ccIn1msb || msg2 == ccIn1lsb ? (
      msg2 == ccIn1msb ? cutmodmsb = msg3;
      msg2 == ccIn1lsb ? cutmodlsb = msg3;
      cutmodval = (cutmodmsb/127.9921875)+(cutmodlsb/16384);   
    );
    msg2 == ccIn2msb || msg2 == ccIn2lsb ? (
      msg2 == ccIn2msb ? resmodmsb = msg3;
      msg2 == ccIn2lsb ? resmodlsb = msg3;
      resmodval = (resmodmsb/127.9921875)+(resmodlsb/16384);   
    );
  );
  midisend(offset, msg1, msg2, msg3);
);

@sample
// Process mono if selected
mono ? (
  tmp = (spl0 + spl1) * 0.5;
  spl0 = spl1 = tmp;
);

// Apply drive
input0 = spl0 * drive;
input0 = input0 / (1 + abs(input0));
input1 = mono ? input0 : (spl1 * drive) / (1 + abs(spl1 * drive));

// Calculate filter coefficients based on selected type
filtertype == 0 ? ( // Prophet-5
  f = 2.0 * $pi * freq / srate;
  k = 4.0 * res;
  p = 0.5;
) : filtertype == 1 ? ( // OB-X
  f = 2.0 * freq / srate;
  k = 3.8 * f - 1.8 * f * f - 1.0;
  p = (k + 1.0) * 0.5;
) : filtertype == 2 ? ( // SEM
  f = 2.0 * sin($pi * freq / srate);
  k = 3.9 * f - 1.9 * f * f - 1.0;
  p = (k + 1.0) * 0.5;
) : filtertype == 3 ? ( // MS-20
  f = 2.0 * freq / srate;
  k = 3.7 * f - 1.7 * f * f - 1.0;
  p = (k + 1.0) * 0.5;
) : filtertype == 4 ? ( // Moog
  f = 2.0 * freq / srate;
  k = 3.6 * f - 1.6 * f * f - 1.0;
  p = (k + 1.0) * 0.5;
) : filtertype == 5 ? ( // Moog 4-Pole
  f = 2 * freq / srate;
  k = 3.6 * f - 1.6 * f * f - 1.0;
  p = (k + 1.0) * 0.5;
  scale = exp((1-p)*1.386249);
  r = res * scale;
  
  // Process left channel
  xl = input0 - r * moog4p_y4l;
  moog4p_y1l = xl*p + moog4p_oldxl*p - k*moog4p_y1l;
  moog4p_y2l = moog4p_y1l*p + moog4p_oldy1l*p - k*moog4p_y2l;
  moog4p_y3l = moog4p_y2l*p + moog4p_oldy2l*p - k*moog4p_y3l;
  moog4p_y4l = moog4p_y3l*p + moog4p_oldy3l*p - k*moog4p_y4l;
  
  moog4p_oldxl = xl;
  moog4p_oldy1l = moog4p_y1l;
  moog4p_oldy2l = moog4p_y2l;
  moog4p_oldy3l = moog4p_y3l;
  
  mono == 0 ? (
    xr = input1 - r * moog4p_y4r;
    moog4p_y1r = xr*p + moog4p_oldxr*p - k*moog4p_y1r;
    moog4p_y2r = moog4p_y1r*p + moog4p_oldy1r*p - k*moog4p_y2r;
    moog4p_y3r = moog4p_y2r*p + moog4p_oldy2r*p - k*moog4p_y3r;
    moog4p_y4r = moog4p_y3r*p + moog4p_oldy3r*p - k*moog4p_y4r;
    
    moog4p_oldxr = xr;
    moog4p_oldy1r = moog4p_y1r;
    moog4p_oldy2r = moog4p_y2r;
    moog4p_oldy3r = moog4p_y3r;
  );
  
  // Set output based on filter mode
  filtermode == 0 ? ( // LP
    spl0 = moog4p_y4l * outgain;
    spl1 = mono ? spl0 : moog4p_y4r * outgain;
  ) : filtermode == 1 ? ( // HP
    spl0 = (input0 - moog4p_y4l) * outgain;
    spl1 = mono ? spl0 : (input1 - moog4p_y4r) * outgain;
  ) : ( // BP
    spl0 = (moog4p_y3l - moog4p_y4l) * outgain * 6;
    spl1 = mono ? spl0 : (moog4p_y3r - moog4p_y4r) * outgain * 6;
  );
) : filtertype == 6 ? ( // Apple 12-Pole Butterworth
  // Calculate frequency and resonance
  sx = 16 + freq * 1.20103 / 200;  
  cx = floor(exp(sx*log(1.059))*8.17742);
  cutoff = 2 * cx / srate;
  res_scaled = (1 - slider5) * 1.5;  // Invert and scale resonance for proper response

  // Calculate coefficients
  k = 0.5 * res_scaled * sin($pi * cutoff);
  c1 = 0.5 * (1 - k)/(1 + k);
  c2 = (0.5 + c1) * cos($pi * cutoff);
  c3 = filtermode == 0 ? 
       (0.5 + c1 - c2) * 0.25 :   // LP
       (0.5 + c1 + c2) * 0.25;    // HP

  // Set coefficients
  a0 = 2 * c3;
  a1 = filtermode == 0 ? 4*c3 : -4*c3;
  a2 = 2 * c3;
  b1 = -2 * c2;
  b2 = 2 * c1;

  // Process left channel with cascaded filter sections
  x = input0;
  loop(6,
    out = a0*x + a1*apple_mem_l11 + a2*apple_mem_l12 
          - b1*apple_mem_l13 - b2*apple_mem_l14;
    apple_mem_l12 = apple_mem_l11;
    apple_mem_l11 = x;
    apple_mem_l14 = apple_mem_l13;
    apple_mem_l13 = out;
    x = out;
  );
  spl0 = out * outgain;
  
  // Process right channel if stereo
  mono == 0 ? (
    x = input1;
    loop(6,
      out = a0*x + a1*apple_mem_r11 + a2*apple_mem_r12
            - b1*apple_mem_r13 - b2*apple_mem_r14;
      apple_mem_r12 = apple_mem_r11;
      apple_mem_r11 = x;
      apple_mem_r14 = apple_mem_r13;
      apple_mem_r13 = out;
      x = out;
    );
    spl1 = out * outgain;
  ) : spl1 = spl0;

) : filtertype == 7 ? ( // Apple 2-Pole
  // Calculate coefficients
  sx = 16 + freq * 1.20103 / 200;  // Map frequency to exponential scale
  cx = floor(exp(sx*log(1.059))*8.17742);
  cutoff = 2 * cx / srate;
  res_scaled = pow(10, 0.05 * -(slider5 * 50)); // Map resonance 0-0.85 to 0-25dB
  
  // Original Apple coefficient calculation
  k = 0.5 * res_scaled * sin($pi * cutoff);
  c1 = 0.5 * (1 - k) / (1 + k);
  c2 = (0.5 + c1) * cos($pi * cutoff);
  c3 = (0.5 + c1 - c2) * 0.25;

  a0 = 2 * c3;
  a1 = 2 * 2 * c3; 
  a2 = 2 * c3;
  b1 = 2 * -c2;
  b2 = 2 * c1;

  // Process left channel
  outputl = a0*input0 + a1*apple2p_x1l + a2*apple2p_x2l - b1*apple2p_y1l - b2*apple2p_y2l;
  apple2p_x2l = apple2p_x1l;
  apple2p_x1l = input0;
  apple2p_y2l = apple2p_y1l;
  apple2p_y1l = outputl;
  spl0 = outputl * outgain;

  // Process right channel if stereo
  mono == 0 ? (
    outputr = a0*input1 + a1*apple2p_x1r + a2*apple2p_x2r - b1*apple2p_y1r - b2*apple2p_y2r;
    apple2p_x2r = apple2p_x1r;
    apple2p_x1r = input1;
    apple2p_y2r = apple2p_y1r;
    apple2p_y1r = outputr;
    spl1 = outputr * outgain;
  ) : spl1 = spl0;

) : (
// Process left channel
  x = input0 - res * y4l;
  y1l = x * p + oldxl * p - k * y1l;
  y2l = y1l * p + oldy1l * p - k * y2l;
  y3l = y2l * p + oldy2l * p - k * y3l;
  y4l = y3l * p + oldy3l * p - k * y4l;

  oldxl = x;
  oldy1l = y1l;
  oldy2l = y2l;
  oldy3l = y3l;

  // Process right channel if stereo
  mono == 0 ? (
    x = input1 - res * y4r;
    y1r = x * p + oldxr * p - k * y1r;
    y2r = y1r * p + oldy1r * p - k * y2r;
    y3r = y2r * p + oldy2r * p - k * y3r;
    y4r = y3r * p + oldy3r * p - k * y4r;

    oldxr = x;
    oldy1r = y1r;
    oldy2r = y2r;
    oldy3r = y3r;
  );

  // Set output based on filter mode
  filtermode == 0 ? ( // LP
    spl0 = y4l * outgain;
    spl1 = mono ? spl0 : y4r * outgain;
  ) : filtermode == 1 ? ( // HP
    spl0 = (input0 - y4l) * outgain;
    spl1 = mono ? spl0 : (input1 - y4r) * outgain;
  ) : ( // BP
    spl0 = (y3l - y4l) * outgain;
    spl1 = mono ? spl0 : (y3r - y4r) * outgain;
  );
);

// Apply limiter if enabled
limiter == 0 ? (
  spl0 = min(max(spl0, -1), 1);
  spl1 = min(max(spl1, -1), 1);
);

// Add ReaRack2 modulation processing for Moog filter
filtertype == 4 ? ( // Moog filter selected
  ccIn1msb == -1 ? cutmodval = 0;
  ccIn2msb == -1 ? resmodval = 0;

  // Process modulation
  msx = ssx-((ssx-cutrange)*cutmodval);
  mres = res-((res-resrange)*resmodval);

  msx != premsx || mres != premres ? (
    sx = 16+(100*msx)*1.20103;
    cutoff = exp(sx*log(1.059))*8.17742;

    f = 2 * cutoff / srate;
    tk = 3.6*f-1.6*f*f-1;
    tp = (tk+1)*0.5;
    scale = 2.718281828459045^((1-tp)*1.386249);
    tr = mres*scale;

    premsx = msx;
    premres = mres;
  );
);

@gfx 400 140
gfx_r = gfx_g = gfx_b = 1; gfx_a = 0.7;
gfx_x = 10; gfx_y = 10;
gfx_drawstr("Filter Type: ");
gfx_drawstr(filtertype == 0 ? "Prophet-5 Rev3" : 
            filtertype == 1 ? "Oberheim OB-X" :
            filtertype == 2 ? "Oberheim SEM" :
            filtertype == 3 ? "Korg MS-20" :
            filtertype == 4 ? "Moog" : 
            filtertype == 5 ? "Moog 4-Pole" : 
            filtertype == 6 ? "Apple 12-Pole" : "Apple 2-Pole");

gfx_x = 10; gfx_y = 30;
gfx_drawstr("Mode: ");
gfx_drawstr(filtermode == 0 ? "Lowpass" : 
            filtermode == 1 ? "Highpass" : "Bandpass");

gfx_x = 10; gfx_y = 50;
gfx_drawstr("Frequency: "); 
gfx_drawnumber(freq, 0);
gfx_drawstr(" Hz");

// Add ReaRack2 modulation display
filtertype == 4 ? (
  gfx_x = mxmin-110;
  gfx_y = ymax+15;
  gfx_drawstr("Modulation Target: ");
  gfx_drawstr(smodp == 0 ? "Cutoff" : "Resonance");
  
  gfx_x = mxmin-110;
  gfx_y = ymax+30;
  gfx_drawstr("CC Input: ");
  gfx_drawnumber(sccIn,0);
);